#!/usr/bin/env python3

import argparse
import os
import shutil
import sys
import unicodedata
from copy import copy
from dataclasses import dataclass
from functools import partial
from multiprocessing import Pool
from pathlib import Path
from typing import Iterator, TextIO


# HELP "./findt <path> <contents...>; search for text <contents> in <path> (dir or file)


class UTF8Table:
    V_BORDER = "│"
    H_BORDER = "─"
    L_JUNCTION = "├"
    R_JUNCTION = "┤"
    TL_BORDER = "┌"
    TR_BORDER = "┐"
    BL_BORDER = "└"
    BR_BORDER = "┘"

    def __init__(self):
        self.__width, self.height = shutil.get_terminal_size()

    @property
    def width(self) -> int:
        return self.__width - 2

    def top(self):
        return f"{UTF8Table.TL_BORDER}{UTF8Table.H_BORDER * self.width}{UTF8Table.TR_BORDER}"

    def junction(self):
        return f"{UTF8Table.L_JUNCTION}{UTF8Table.H_BORDER * self.width}{UTF8Table.R_JUNCTION}"

    def header(self, string) -> str:
        assert "\n" not in string
        string = string[:self.width]
        mid_section = f"{UTF8Table.V_BORDER}{string:<{self.width}}{UTF8Table.V_BORDER}"
        return "\n".join([self.top(), mid_section, self.junction()])

    def row(self, string) -> str:
        string = string[:self.width]
        return f"{UTF8Table.V_BORDER}{string:<{self.width}}{UTF8Table.V_BORDER}"

    def bot(self) -> str:
        return f"{UTF8Table.BL_BORDER}{UTF8Table.H_BORDER * self.width}{UTF8Table.BR_BORDER}"


# https://stackoverflow.com/a/518232
def normalize(string, normalized=False) -> str:
    if not normalized:
        return string
    return "".join(c for c in unicodedata.normalize("NFD", string) if unicodedata.category(c) != "Mn")


def upper(string, uppercase=False) -> str:
    if not uppercase:
        return string
    return string.upper()


def merge_intervals(intervals):
    # sort intervals by start time
    intervals.sort(key=lambda x: x[0])

    merged = []
    for interval in intervals:
        # If the list of merged intervals is empty or if the current interval does not overlap with the previous, append it to merged
        if not merged or merged[-1][1] < interval[0]:
            merged.append(interval)
        else:
            # Otherwise, there is overlap, so we merge the current and previous intervals
            merged[-1][1] = max(merged[-1][1], interval[1])

    return merged


@dataclass
class Block:
    owner: Path
    _query: str
    _query_uppercase: bool
    _query_normalized: bool

    before: list[str]
    exact_match_lc: int
    exact_match: str
    after: list[str]

    @property
    def rank(self) -> int:
        return self.exact_match_lc + 1

    def lines(self) -> Iterator[tuple[int, str]]:
        block_lc = self.rank - len(self.before)
        for bline in self.before:
            yield block_lc, bline
            block_lc += 1

        yield block_lc, self.exact_match
        block_lc += 1

        for aline in self.after:
            yield block_lc, aline
            block_lc += 1

        return


class Aggregate:
    def __init__(self, owner: Path, padding: int):
        self.__owner: Path = owner
        self.__padding: int = padding
        self.__pqueries: list[str] = []
        self.__lines: dict[int, str] = {}
        self.__matched_lines: list[int] = []
        self.__start_lc: int = 9999999
        self.__end_lc: int = -1

    def aggregate(self, blocks: list[Block]) -> None:
        blocks = sorted(blocks, key=lambda b: b.rank)
        for b in blocks:
            self.__matched_lines.append(b.rank)
            self.__pqueries.append(b._query)
            for line_count, line in b.lines():
                self.__start_lc = min(line_count, self.__start_lc)
                self.__end_lc = max(line_count, self.__end_lc)
                if line_count in self.__lines:
                    continue
                self.__lines[line_count] = line

    def ppretty(self) -> Iterator[tuple[bool, str]]:
        max_lc_padding = len(str(self.__end_lc))

        def build(lc: int, line: str) -> str:
            return f"{format(lc, str(max_lc_padding) + 'd')}: {line}"

        header_content = f" ".join(list(map(str, sorted(self.__matched_lines))))
        yield True, f"{self.__owner} lines~{self.__padding}: {header_content}"

        old_k = -1
        first = True
        for k in sorted(self.__lines.keys()):
            is_seq = old_k + 1 == k
            if first:
                first = False
                is_seq = True

            yield is_seq, build(k, self.__lines[k])
            old_k = k

        return


def match_blocks(file: Path,
                 queries: list[str],
                 padding: int = 2,
                 normalized: bool = False,
                 uppercase: bool = False) -> Iterator[Block]:
    def insert(q: list, e: object, padding: int = padding) -> None:
        assert len(q) <= padding
        if len(q) >= padding:
            # remove the oldest element (if we're using .append)
            q.pop(0)
        q.append(e)

    def advance(f: TextIO) -> Iterator[tuple[int, str]]:
        tell = f.tell()
        while True:
            line = upper(normalize(f.readline().rstrip(), normalized=normalized), uppercase=uppercase)
            yield tell, line
            previous_tell = tell
            tell = f.tell()
            if tell == previous_tell:
                return

    def peek(f: TextIO, pc: int) -> list[str]:
        """
        :param f: fhandle
        :param pc: peek count
        """
        tell = f.tell()
        try:
            lines = []
            advance_iterator = advance(f)
            for i in range(pc):
                _, line = next(advance_iterator)
                lines.append(line)
                itell = f.tell()
                if tell == itell:
                    return lines
            return lines
        finally:
            f.seek(tell)

    def drive(f: TextIO, padding: int = padding) -> Iterator[Block]:
        lc = 0
        before = []
        for tell, line in advance(f):
            truthy_query_results = []
            for query in queries:
                query = upper(normalize(query, normalized=normalized), uppercase=uppercase)
                if query in line:
                    truthy_query_results.append(query)

            yield from map(
                lambda query: Block(
                    owner=file,
                    _query=query,
                    _query_uppercase=uppercase,
                    _query_normalized=normalized,
                    before=copy(before),
                    after=peek(f, padding),
                    exact_match=line,
                    exact_match_lc=lc
                ),
                truthy_query_results
            )
            insert(before, line)
            lc += 1
        return

    if not file.exists():
        return []
    try:
        with open(file, "r") as fhandle:
            yield from drive(fhandle, padding=padding)
    except UnicodeDecodeError:
        pass  # silently skip undecodeable files


def preprocess(directory: Path) -> list[Path]:
    """
    Find all files from the directory provided, and return their path.
    If the path provided is a file, it will return itself.
    :returns: list of absolute files, that exist
    """
    if directory is None:
        raise ValueError("dir null not permitted")
    if not directory.exists():
        return []
    if directory.is_file():
        return [directory]
    # block devices etc. check
    if not directory.is_dir():
        return []
    return list(
        filter(
            lambda p: p.is_file(),
            map(
                lambda p: p,
                [Path(p) for p in directory.rglob("*")]
            )
        )
    )


def pmap_match(path, options) -> tuple[str, list[Block]] | tuple[None, None]:
    matched_blocks = match_blocks(
        path,
        queries=options.filters,
        padding=options.padding,
        normalized=options.normalized,
        uppercase=options.insensitive
    )
    key = str(path)
    blocks = []
    try:
        for block in matched_blocks:
            blocks.append(block)
        return key, blocks
    except PermissionError:
        print(f"Permission denied to read {key}!", file=sys.stderr)
    return None, None


def main(options):
    padding = options.padding
    decorated = options.decorated
    multimatches: dict[str, list[Block]] = {}
    paths = preprocess(Path(options.path))

    partial_match = partial(pmap_match, options=options)
    with Pool(os.cpu_count()) as pool:
        match_filter = lambda res: bool(res[1])
        results = tuple(filter(match_filter, pool.map(partial_match, paths)))
        for k, v in results:
            multimatches[k] = v

    for k, v in multimatches.items():
        aggregate = Aggregate(Path(k), padding)
        aggregate.aggregate(v)
        if not decorated:
            for _, entry in aggregate.ppretty():
                print(entry)

        if decorated:
            ppretty = aggregate.ppretty()
            _, header = next(ppretty)
            table = UTF8Table()
            print(table.header(header))
            for is_seq, table_entry in ppretty:
                if not is_seq:
                    print(table.junction())
                print(table.row(table_entry))
            print(table.bot())


@dataclass
class UserOptions:
    path: str
    filters: list[str]
    # -i, --insensitive
    insensitive: bool
    normalized: bool
    # --padding <int>
    padding: int
    # --no-decorations is the inverse of this value
    decorated: bool


def _parse_args(args) -> UserOptions:
    parser = argparse.ArgumentParser(description="findt: a recursive content text locator")
    parser.add_argument("path", type=str)
    parser.add_argument("filters", nargs="+")
    parser.add_argument("-i", "--insensitive", default=False, action="store_true")
    parser.add_argument("-d", "--no-decorations", default=False, action="store_true")
    parser.add_argument("--padding", type=int, default=2, required=False)
    options = parser.parse_args(args)
    return UserOptions(
        path=options.path,
        filters=options.filters,
        insensitive=options.insensitive,
        normalized=options.insensitive,
        padding=options.padding,
        decorated=not options.no_decorations
    )


if __name__ == "__main__":
    main(_parse_args(sys.argv[1:]))
