#!/usr/bin/env python3

import os
import sys
import enum
import shutil
import unicodedata
from dataclasses import dataclass
from pathlib import Path
from functools import partial
from typing import Iterator, TextIO
from copy import copy

# HELP "./findt <path> <contents...>; search for text <contents> in <path> (dir or file)

class Colours(enum.Enum):
    RED = "\033[32m"
    CLR = "\033[0m"


class UTF8Table:
    V_BORDER   = "│"
    H_BORDER   = "─"
    L_JUNCTION = "├"
    R_JUNCTION = "┤"
    TL_BORDER  = "┌"
    TR_BORDER  = "┐"
    BL_BORDER  = "└"
    BR_BORDER  = "┘"

    def __init__(self):
        self.width, self.height = shutil.get_terminal_size()

    def header(self, string) -> str:
        assert "\n" not in string
        string = string[:self.width - 2]
        strwidth = self.width-2
        top_section  = f"{UTF8Table.TL_BORDER}{UTF8Table.H_BORDER*(self.width - 2)}{UTF8Table.TR_BORDER}"
        mid_section  = f"{UTF8Table.V_BORDER}{string:<{strwidth}}{UTF8Table.V_BORDER}"
        bot_junction = f"{UTF8Table.L_JUNCTION}{UTF8Table.H_BORDER*(self.width - 2)}{UTF8Table.R_JUNCTION}"
        return "\n".join([top_section, mid_section, bot_junction])

    def row(self, string) -> str:
        strwidth = self.width-2
        string = string[:self.width - 2]
        return f"{UTF8Table.V_BORDER}{string:<{strwidth}}{UTF8Table.V_BORDER}"

    def end(self) -> str:
        return f"{UTF8Table.BL_BORDER}{UTF8Table.H_BORDER*(self.width - 2)}{UTF8Table.BR_BORDER}"


# https://stackoverflow.com/a/518232
def normalize(string, normalized=False) -> str:
    if not normalized:
        return string
    return "".join(c for c in unicodedata.normalize("NFD", string) if unicodedata.category(c) != "Mn")

def upper(string, uppercase=False) -> str:
    if not uppercase:
        return string
    return string.upper()


@dataclass
class Block:
    owner: Path
    query: str

    before: list[str]
    exact_match_lc: int
    exact_match: str
    after: list[str]

    @property
    def rank(self) -> int:
        return self.exact_match_lc + 1

    def lines(self) -> Iterator[tuple[int, str]]:
        block_lc = self.rank -len(self.before)
        for bline in self.before:
            yield block_lc, bline
            block_lc += 1

        yield block_lc, self.exact_match
        block_lc += 1

        for aline in self.after:
            yield block_lc, aline
            block_lc += 1

        return

class Aggregate:
    def __init__(self, owner: Path, padding: int):
        self.__owner: Path = owner
        self.__padding: int = padding
        self.__queries: list[str] = []
        self.__lines: dict[str, str] = {}
        self.__matched_lines: list[int] = []
        self.__start_lc: int = 9999999
        self.__end_lc: int = -1

    def aggregate(self, blocks: list[Block]) -> None:
        blocks = sorted(blocks, key=lambda b: b.rank)
        for b in blocks:
            self.__matched_lines.append(b.rank)
            for line_count, line in b.lines():
                self.__start_lc = min(line_count, self.__start_lc)
                self.__end_lc = max(line_count, self.__end_lc)
                if line_count in self.__lines:
                    continue
                self.__lines[line_count] = line

    def ppretty(self, decorated: bool = False) -> str:
        MAX_LC_PADDING = len(str(self.__end_lc))
        def decorate(lc, line) -> str:
            if not decorated or lc not in self.__matched_lines:
                return line
            raise NotImplementedError()  # TODO implement

        def is_sequential(oldk, newk) -> bool:
            return oldk + 1 == newk

        def build(lc: int, line: str) -> str:
            return f"{format(lc, f"{MAX_LC_PADDING}d")}: {decorate(lc, line)}"

        header_content = ' '.join(list(map(str, sorted(self.__matched_lines))))
        yield f"{self.__owner} lines~{self.__padding}: {header_content}"

        previous_k = 0
        for k in sorted(self.__lines.keys()):
            # if this is not a sequential line, and it's insignificant, show ...
            if not is_sequential(previous_k, k) and k not in self.__matched_lines:
                previous_k = k
                yield build(k, "...")
                continue
            yield build(k, self.__lines[k])
            previous_k = k

        return


def match_blocks(file: Path,
                 queries: list[str],
                 padding:int = 2,
                 normalized: bool = False,
                 uppercase: bool = False) -> Iterator[Block]:
    def insert(q: list, e: object, padding:int = padding) -> None:
        assert len(q) <= padding
        if len(q) >= padding:
            # remove the oldest element (if we're using .append)
            q.pop(0)
        q.append(e)

    def advance(f: TextIO) -> Iterator[tuple[int, str]]:
        previous_tell = None
        tell = f.tell()
        while True:
            line = upper(normalize(f.readline().strip(), normalized=normalized), uppercase=uppercase)
            yield tell, line
            previous_tell = tell
            tell = f.tell()
            if tell == previous_tell:
                return

    def peek(f: TextIO, pc: int) -> Iterator[str]:
        """
        :param pc: peek count
        """
        tell = f.tell()
        try:
            lines = []
            for i in range(pc):
                lines.append(upper(normalize(f.readline().strip(), normalized=normalized), uppercase=uppercase))
                itell = f.tell()
                if tell == itell:
                    return lines
            return lines
        finally:
            f.seek(tell)

    def drive(f: TextIO, padding: int = padding) -> Iterator[Block]:
        lc = 0
        before=[]
        after=[]
        for tell, line in advance(f):
            truthy_query_results = []
            for query in queries:
                if query in line:
                    truthy_query_results.append(query)

            matched = bool(truthy_query_results)
            yield from map(
                lambda query: Block(
                    owner=file,
                    query=query,
                    before=copy(before),
                    after=peek(f, padding),
                    exact_match=line,
                    exact_match_lc=lc
                ),
                truthy_query_results
            )
            insert(before, line)
            lc += 1
        return

    assert file.exists()
    try:
        with open(file, "r") as fhandle:
            yield from drive(fhandle, padding=padding)
    except UnicodeDecodeError as ignored:
        pass  # silently skip undecodeable files


def preprocess(dir: Path) -> list[Path]:
    """
    Find all files from the directory provided, and return their path.
    If the path provided is a file, it will return itself.
    :returns: list of absolute files, that exist
    """
    if dir is None:
        raise ValueError("dir null not permitted")
    if not dir.exists():
        return []
    if dir.is_file():
        return [dir]
    # block devices etc. check
    if not dir.is_dir():
        return []
    return list(
        filter(
            lambda p: p.is_file(),
            map(
                lambda p: p,
                [Path(p) for p in dir.rglob("*")]
            )
        )
    )


def main():
    if len(sys.argv) < 3:
        print("./findt <path> <contents...> argument must be given!")
        exit(2)

    padding = 3
    uppercase = False
    normalized = False
    multimatches: dict[str, Block] = {}
    paths = preprocess(Path(sys.argv[1]))
    for p in paths:
        matched_blocks = match_blocks(
            p,
            queries=sys.argv[2:],
            padding=padding,
            normalized=normalized,
            uppercase=uppercase
        )

        key = str(p)
        try:
            for block in matched_blocks:
                if key not in multimatches:
                    multimatches[key] = [block]
                    continue
                multimatches[key].append(block)
        except PermissionError:
            print(f"Permission denied to read {key}!", file=sys.stderr)

    for k, v in multimatches.items():
        aggregate = Aggregate(Path(k), padding)
        aggregate.aggregate(v)
        ppretty = aggregate.ppretty()
        header = next(ppretty)
        table = UTF8Table()
        print(table.header(header))
        for table_entry in ppretty:
            print(table.row(table_entry))
        print(table.end())


@dataclass
class UserOptions:
    # -i, --insensitive
    insensitive: bool
    normalize: bool
    # --padding <int>
    padding: int
    # --no-highlight is the inverse of this value
    highlight: bool
    # --no-decorations is the inverse of this value
    decorations: bool


if __name__ == "__main__":
    main()
